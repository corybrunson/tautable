?require
?install.packages
r <- getOption("repos")
r["CRAN"] <- "http://my.local.cran"
options(repos = r)
pkgs <- c('stats', 'Kendall', 'pcaPP')
for(pkg in pkgs) {
if(!require(pkg, character.only = TRUE)) {
install.packages(pkg)
stopifnot(require(pkg))
}
}
ceiling
Kendall(1:5,5:1)
Kendall(1:5,5:1)$p
Kendall(1:5,5:1)$pvalue
Kendall(1:5,5:1)$p.value
names(Kendall(1:5,5:1))
Kendall(1:5,5:1)$sl
n <- 30
k.ran <- c(0, floor(choose(n, 2) / 2))
inv.vec <- function(n, k, bw.ok = TRUE) {
if(k > choose(n, 2) | k < 0 | any(c(n, k) %% 1 != 0)) stop('invalid n or k')
backwards <- (k > choose(n, 2) / 2) & bw.ok
if(backwards) k <- choose(n, 2) - k
vec <- 1:n; ninv <- 0
while(ninv < k) {
i <- vec[1]
j <- if(k - ninv < n - i) (2 + k - ninv):n else {
if(i == 1) c() else (2 + n - i):n
}
vec <- c(vec[-c(1, j)], i, vec[j])
ninv <- ninv + {
if(k - ninv < n - i) (k - ninv) else (n - i)
}
stopifnot(ninv == vec.inv(vec))
}
if(backwards) vec <- rev(vec)
return(vec)
}
p.ran <- sapply(k.ran, function(k) Kendall(x = 1:n, y = inv.vec(n, k))$sl)
# Count inversions in a vector
vec.inv <- function(vec) {
sum(unlist(sapply(1:(length(vec) - 1), function(i) {
sapply((i + 1):length(vec), function(j) vec[i] > vec[j])
})))
}
p.ran <- sapply(k.ran, function(k) Kendall(x = 1:n, y = inv.vec(n, k))$sl)
p.ran
Kendall(x=1:n,y=inv.vec(n,floor(k.ran[2]/2)))$sl
Kendall(x=1:n,y=inv.vec(n,floor(k.ran[2])))$sl
?Kendall
p.ran <- sapply(k.ran, function(k) Kendall(x = 1:n, y = inv.vec(n, k))$sl / 2)
p.ran
diff(p.ran)
if(p <= p.ran[1] | p >= p.ran[2]) break
n <- 30; p <- .01
if(p <= p.ran[1] | p >= p.ran[2]) break
q <- (p - p.ran[1]) / diff(p.ran)
q
round(pi)
k <- round(q * diff(k.ran) + k.ran[1])
k
if(k == k.ran[1]) k <- k + 1 else if(k == k.ran[2]) k <- k - 1
k
p <- Kendall(x = 1:n, y = inv.vec(n, k))$sl / 2
p
n <- 30; p <- .01
n <- 30; p <- .01
# range of revelant k (at most half of all possible discordant pairs)
k.ran <- c(0, floor(choose(n, 2) / 2))
# corresponding one-sided p-values
p.ran <- sapply(k.ran, function(k) Kendall(x = 1:n, y = inv.vec(n, k))$sl / 2)
# interpolate
repeat {
if(p <= p.ran[1]) {
k <- NA; break
}
if(p > p.ran[2]) {
k <- k.ran[2]; break
}
q <- (p - p.ran[1]) / diff(p.ran)
k <- round(q * diff(k.ran) + k.ran[1])
if(k == k.ran[1]) k <- k + 1 else if(k == k.ran[2]) k <- k - 1
k.p <- Kendall(x = 1:n, y = inv.vec(n, k))$sl / 2
if(k.p == p) break else if(k.p < p) {
k.ran[1] <- k; p.ran[1] <- k.p
} else if(k.p > p) {
k.ran[2] <- k; p.ran[2] <- k.p
}
if(diff(k.ran) < 2) {
k <- k.ran[1]; break
}
}
k
tau  <- (choose(n, 2) - 2 * k) / choose(n, 2)
print(paste('tau must beat', tau))
print(paste('tau must beat', round(tau, 3)))
?cor.test
n <- 30; p <- .01
# range of revelant k (at most half of all possible discordant pairs)
k.ran <- c(0, floor(choose(n, 2) / 2))
# corresponding one-sided p-values
p.ran <- sapply(k.ran, function(k) cor.test(x = 1:n, y = inv.vec(n, k),
alternative = 't',
method = 'kendall')$p.value / 2)
k.ran
p.ran
repeat {
if(p <= p.ran[1]) {
k <- NA; break
}
if(p > p.ran[2]) {
k <- k.ran[2]; break
}
q <- (p - p.ran[1]) / diff(p.ran)
k <- round(q * diff(k.ran) + k.ran[1])
if(k == k.ran[1]) k <- k + 1 else if(k == k.ran[2]) k <- k - 1
k.p <- cor.test(x = 1:n, y = inv.vec(n, k),
alternative = 't', method = 'kendall')$p.value / 2
if(k.p == p) break else if(k.p < p) {
k.ran[1] <- k; p.ran[1] <- k.p
} else if(k.p > p) {
k.ran[2] <- k; p.ran[2] <- k.p
}
if(diff(k.ran) < 2) {
k <- k.ran[1]; break
}
}
tau.s  <- (choose(n, 2) - 2 * k) / choose(n, 2)
print(paste('tau must beat', round(tau.s, 3)))
require(Kendall)
x=1:5
y=c(1,3,4,5,2)
test <- cor.test(x=x,y=y,alternative='t',method='kendall')
wh.tau.p <- sapply(c(tau.part, p.part), function(part) {
which(names(test) == part)
})
tau.part ='estimate'
p.part='p.value'
wh.tau.p <- sapply(c(tau.part, p.part), function(part) {
which(names(test) == part)
})
wh.tau.p
test[wh.tau.p]
unname(test[wh.tau.p])
unname(unlist(test)[wh.tau.p])
unlist(unname(test[wh.tau.p]))
test<-Kendall(x=x,y=y)
tau.part='tau'
p.part='sl'
wh.tau.p <- sapply(c(tau.part, p.part), function(part) {
which(names(test) == part)
})
wh.tau.p
unlist(unname(test[wh.tau.p]))
